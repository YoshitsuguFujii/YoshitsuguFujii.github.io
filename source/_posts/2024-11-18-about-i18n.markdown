---
layout: post
title: " i18nについて思ったこと"
date: 2024-11-18 20:20:18 +0900
comments: true
categories: [ruby,ruby on rails]
---

ランニング用のLサイズのパンツを楽天で買ったんです。  
届いて気がつきました。  
レディースを買っていたことに。

しょうがないのでお尻をプリプリさせながら、朝から40過ぎのおっさんが街中を走っていたんですが、ついに先日少し破れまして、躊躇なく捨てることができました！


めちゃくちゃ嬉しかった！

嬉しくて近所のまいばすけっとでシャンパン買ってきて夜は乾杯しました。


さて本題。  

ある現場でi18nは直感的に見えづらい、国際化対応はまずやらないし、必要であればその時にやればよろしい。またラベルにした時にその文言が正しいのか判断を奪うので良くない。  
という観点でモデルに関するi18nをつかった変換が文字列リテラルに書き換えられていた時に自分が思ったことです。

<!-- more -->  

## 文字列リテラルをそのまま使うこと

文字列リテラルってたしかに直感的で便利なんですが、ただの文字列でしかないんですよね。値それ以上の意味はない。  
  
文字の内容がたしかに雄弁に語っているように見える、見えるんですがその文字が意味するものはコンテキストによるうっすらとした結合でしかないんです。  
ほぼ何にも紐づいていない。  
  
例えばUserコントローラーのshowアクションに書かれていた文字列リテラル(ユーザー等)の場合はUserリソース関連の処理だなとはわかる。  
が、これは人間の認知力に完全に頼った理解であり、プログラム的には何も表現されていないし、実際に何も紐づいていないんです。  
  
ユーザーとメンバーとカスタマーという概念があり、所属グループ、所属企業、サークルがある。  
別々のコンテキストでユーザーという文字を埋め込むと、それはどれを表現しているといえますか？  
  
そのユーザーはControllerではメンバーを表しているかも知れないし、viewでは所属と紐づける中間テーブルを表しているかもしれません。  
しかし文字列リテラルはコード的には何も色付けされていないわけですから、そのユーザーという文字列がどの業務(ドメイン)領域のユーザーを表しているか？ということについては何も語ってくれないわけです。  
  
これは文字列リテラルをなぜわざわざ定数として定義するのかの解にもなります。  
  
定数として定義することにより、この文字列リテラルは特殊であり、そのクラスの所属であり、スコープはクラスに閉じるよ。  
このクラスのコンテキストで利用するよということがわかるんです。  
  
定数としてこのクラスの特別な文字列として宣言する(クラスの色を付けてあげる)。  
そうすると影響が読みやすく、わかりやすくて変更が楽で安全なコードになるわけです。  
定数として宣言することで文字列以上の働きと意味をもたせることができるようになります。  
  
クラスの色をつけるといういう意味であれば、型付け言語であればメソッドを持たない型でありながら単純な文字列を格納するstatusというフィールドにstatusという型を明示的に定義する感覚に近いと思っています。  

```
type status string
```


番外編としてはIDEの恩恵設けれますね。    

### i18nの国際化対応以外の効用 
で最初に戻るんですが、i18nは国際化対応としての機能だけだと認識されがちです。  
それ以外のメリットってないんでしょうか？  
  
ヒントは先程の定数化（文字列の所属化、特定クラスの色をつける）と、デコレータにあります。  
modelに紐づけたlocaleの定義って、railsが規約にのっとって自動的にモデルと紐づけてくれるんです。  
その定義はモデルの所属になりますしスコープもそのモデルに限定されます。  
そして対応する言葉を返すrailsの仕組みを介したデコレータにもなります。   
  

```yaml
# config/locales/ja.yml
ja:
  activerecord:
    models:
      user: ユーザー
    attributes:
      user:
        name: 名前
        email: メールアドレス
        created_at: 作成日
        updated_at: 更新日
```

```ruby
User.model_name.human # => "ユーザー"
User.human_attribute_name(:name) # => "名前"
```


さきほどのユーザーとメンバーとカスタマーの例に戻りましょう。  
かなり強引ですが、以下の用に設定したとしましょう。  

```yaml
ja:
  activerecord:
    models:
      user: ユーザー
      member: ユーザー
      customer: ユーザー
```

```ruby
User.model_name.human # => "ユーザー"
Member.model_name.human # => "ユーザー"
Customer.model_name.human # => "ユーザー"
```

同じユーザーという文字列ですが、それぞれのユーザーという文字列がどのモデルを指しているかわからないという人はいないでしょう。  
  
文字列を所属化することでプログラム的に判断できるようになっています。  
その処理の前後、あるいは書かれた場所を考慮してあやふやな人間の認知力によって判断する必要はありません。  
  
人の認知力に頼らずプログラム的にユーザーという文字列にモデルクラスをあてることにより文字列の所属を明らかにしています。  
  
これがただの文字列で埋め込まれていた場合。例えばCustomerの文脈で使われている`ユーザー`という文字列を`購入者`としたいという仕様変更が入った場合。 人間の認知力にたよって前後の処理、書かれた場所のユーザーという文字列からCustomerの文脈で使われている箇所を徹底的に探し出し、修正しなければいけません。  
  
影響が閉じていないため、修正範囲の特定が困難になり、変更容易性が損なわれています。   
  
DDDなどでは業務の言葉とプログラムで使う言葉を対応させるという書き方をします。  
そうするとプログラムは業務を自然に素直に表現でき、ロジックが書いてある場所に違和感はなくなって適切な場所に配置され、
影響が明確になり、修正箇所も業務の内容がそのまま反映されているため容易に特定できます。  
  
プログラムは英語で書かれます、しかし我々は普段日本語を使う環境にいます。  
日本語を使う我々においてi18nの設定は、間に入ってプログラムの用語(モデルの要素)と日本語の用語をrailsの仕組みを介して1対1で対応させます。 つまり業務の言葉とプログラムで使う言葉を透過的に一致させてくれます。  
  
また単純にモデルの属性に対となる一意な名称を与えるということは、表記揺れを防止するという恩恵もあります。  
  
## まとめ  
  
いかがでしたでしょうか？  
I18nの設定はひと手間かかるし、何が書かれているか設定を見直さないといけないため面倒くさく感じてしまうかもしれません。  
しかしその裏ではその手間以上の意義があると感じています。  
  
もちろん完全にプロジェクト内のコードを1文字残らず把握していて問題ない。把握できないサイズにスケールしない。 チームではないというのであれば問題ないと思います。  
  
- 国際化対応としての機能
- 表記揺れ防止の機能
- 所属化(定数化)させる機能
- デコレータとしての機能
  
みたいなことを考えて自分はi18nを使っています。  
ぜひi18nを使ってみてください。  
