<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

    <title><![CDATA[Category: ruby on rails | なんとなく日々徒然と]]></title>
    <link href="http://yoshitsugufujii.github.io/blog/categories/ruby-on-rails/atom.xml" rel="self"/>
    <link href="http://yoshitsugufujii.github.io/"/>
    <updated>2015-06-08T14:27:31+09:00</updated>
    <id>http://yoshitsugufujii.github.io/</id>
    <author>
        <name><![CDATA[Yoshitsugu Fujii]]></name>
        
      </author>
    <generator uri="http://octopress.org/">Octopress</generator>

    
    <entry>
        <title type="html"><![CDATA[モデルのattributeに変更がなくてもnested_attribute_forを使っているモデルでcallbackを発生させる]]></title>
        <link href="http://yoshitsugufujii.github.io/blog/2015/05/25/force-occur-callbacks/"/>
        <updated>2015-05-25T16:15:38+09:00</updated>
        <id>http://yoshitsugufujii.github.io/blog/2015/05/25/force-occur-callbacks</id>
        <content type="html"><![CDATA[<p>任意の条件でnested_attribute_forの対象の保存処理を走らせる方法です</p>

<p>ファイルのアップロード用のモデルを作っていて<code>ActionDispatch::Http::UploadedFile</code>を一旦attr_accessorのアクセサで受けたあとcallbackでファイル名やファイルサイズをmodelクラスの該当のカラムに設定するという処理を書いておりました。</p>

<p>ファイルは可変にアップロードしたかったのでこのモデルの親モデルから参照するようにして、nested_attribute_forで親モデル更新時に一緒に更新するようにします。</p>

<pre><code class="ruby">class Oya &lt; ActiveRecord::Base
  has_many :files, dependent: :destroy

  accepts_nested_attributes_for :files, allow_destroy: true
end
</code></pre>

<pre><code class="ruby">class File &lt; ActiveRecord::Base
  attr_accessor :file
end
</code></pre>

<!-- more -->


<p>いらない情報ですが、一応モデルクラスFileモデルの参照先のテーブルfilesテーブルはこんな感じです。
<code>ruby
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `created_at` datetime DEFAULT NULL,
  `updated_at` datetime DEFAULT NULL,
  `oya_id` int(11) NOT NULL,
  `data_file_name` varchar(255) DEFAULT NULL,
  `data_content_type` varchar(255) DEFAULT NULL,
  `data_file_size` int(11) DEFAULT NULL,
</code></p>

<p>新規登録の時は良かったんですが、親モデル保存時にnested_attribute_forの対象のモデルクラスのsave(auto_save)やcallbackを走らせるかどうかは実際にデータベースに登録されているカラムの値に変化があったかで決定されているようです(たぶん)</p>

<p>そのため変更時にはformからはfileというアクセサに設定する値のみ飛んでくるような作りだとauto_saveが動かずFileクラスの更新処理が走りませんでした。</p>

<p>そのためchanged_for_autosave?をオーバーライドすることで独自に変更判定を行いcallback並びにauto saveが動くようにします。</p>

<pre><code class="ruby">class File &lt; ActiveRecord::Base
  attr_accessor :file

  def changed_for_autosave?
    if file.present?
      return true
    end
    super
  end
end
</code></pre>

<p>知ってると簡単ですが、知らないとはまりますね。</p>
]]></content>
    </entry>
    
    <entry>
        <title type="html"><![CDATA[nested_formで下じゃなくて上に要素を追加したい場合]]></title>
        <link href="http://yoshitsugufujii.github.io/blog/2015/05/20/nested-form-add-field-to-top/"/>
        <updated>2015-05-20T18:03:26+09:00</updated>
        <id>http://yoshitsugufujii.github.io/blog/2015/05/20/nested-form-add-field-to-top</id>
        <content type="html"><![CDATA[<p>neste_formは可変なサイズの子要素を動的に追加できるGemです。</p>

<p><a href="https://github.com/ryanb/nested_for://github.com/ryanb/nested_form">nested form</a></p>

<p>いつも大変お世話になっておりますが、今回の案件で追加する先を指定したエレメントの下ではなく上に追加しなければいけなくなり対応しました。</p>

<!-- more -->


<p>バージョンは<br/>
<code>ruby Gemfile.lock
nested_form (0.3.2)  
</code>
での作業となります。</p>

<p>ますnested_formで使われるjsを眺めるとそんなに長くない処理であることがわかります。<br/>
その中で追加ボタンを押したときに要素を追加する部分はこの辺りになるようです。</p>

<pre><code class="js jquery_nested_form:55行目あたり">    insertFields: function(content, assoc, link) {
      var target = $(link).data('target');
      if (target) {
        return $(content).appendTo($(target));
      } else {
        return $(content).insertBefore(link);
      }
    },
</code></pre>

<p>ここを上書きします。 <br/>
application.jsで<code>//= require jquery_nested_form</code>の後に以下の処理を書いて上書きしちゃいましよう。</p>

<pre><code class="js">window.NestedFormEvents.prototype.insertFields = function(content, assoc, link) {
  var target = $(link).data('target');
  if ($(link).data('destination') == "prepend"){
    return $(target).prepend($(content));
  }else{
    if (target) {
      return $(content).appendTo($(target));
    } else {
      return $(content).insertBefore(link);
    }
  }
}
</code></pre>

<p>linkのdata-destination=prependで対象の要素の上にprependで追加されるイメージです。</p>

<p>&#8220;`erb</p>

<table id="tasks">
  <%= f.fields_for :tasks, :wrapper => false do |task_form| %>
    <tr class="fields">
      <td><%= task_form.text_field :name %></td>
      <td><%= task_form.link_to_remove "Remove this task" %></td>
    </tr>
  <% end %>
</table>


<p><p>&lt;%= f.link_to_add &ldquo;Add a task&rdquo;, :tasks, :data => { :target => &ldquo;#tasks&rdquo;, :prepend => true } %></p>
&#8220;`</p>

<p>簡単でした。</p>
]]></content>
    </entry>
    
    <entry>
        <title type="html"><![CDATA[Rails Engineを使った開発]]></title>
        <link href="http://yoshitsugufujii.github.io/blog/2015/05/19/develop-with-rails-engine/"/>
        <updated>2015-05-19T13:09:58+09:00</updated>
        <id>http://yoshitsugufujii.github.io/blog/2015/05/19/develop-with-rails-engine</id>
        <content type="html"><![CDATA[<p>一つ前に携わったプロジェクトではサブシステムがたくさんあり、それぞれがrailsで構築されていて共通処理やmodelはrails engineにあつめられ各システムで参照しておりました。</p>

<p>今までgemのコードリーディングをする時にしか意識していなかったrails engineですが(deviseとかとか)、結構便利だということを今更ながら実感し、最近は共有処理をengineに書き出してそれを参照するようにしています。</p>

<p>クックパッドさんでも共通部分をengineに集めているようです。<br/>
<a href="http://techlife.cookpad.com/entry/2015/04/06/155940">新規サービスの管理画面を短期間で見栄え良く実装する</a></p>

<p>ドリコムさんでは複数のengineを組み合わせてシステムを作っているようです。<br/>
<a href="http://blog.onk.ninja/2014/12/02/mountable_engine.html">Mountable Engine だらけの Rails アプリ開発</a></p>

<!-- more -->


<p>でも完全に共通に作ろうとすると色々考えなきゃいけないから工数がかかっちゃうんじゃないかと懸念があるかもしれません。<br/>
でも最初はそこまで共通化する必要もないのではないのかと思います。</p>

<p>git使っていれば、システムの納品段階でengineのブランチを切るなりタグを打つなりして機能を固定してしまえばいいのです。<br/>
そうすれば、今後engineに修正が加わってもGemfileで該当のブランチまたはタグを見るようにすれば問題なく納品段階のengineのコードでシステムは動き続けます。<br/>
その後時間をおいてゆっくりとプロジェクトに依存したコードを共通化していけばいいのです。</p>

<p>これを応用してめったにやらない処理であんまり入れなたくないような機能や、<br/>
モンキーパッチなども参照元のプロジェクト単位でengineをカスタマイズして導入することもできます。</p>

<p>そして共通化した処理を書くことはいつもより有益なことをしてる気持ちで仕事ができるので楽しいです。<br/>
engine固有の仕組みや書き方もあって最初は中々辛い部分もありますが、
engineを使ったことのない方は決まり切った処理をコピぺで過去のプロジェクトから持ってくるのではなく、
その処理をengineに書き出してそれをプロジェクトから参照してみてはいかがでしょうか？</p>
]]></content>
    </entry>
    
    <entry>
        <title type="html"><![CDATA[Railsでbootstrap datetimepickerを日本語化しつつ導入(with rails assets)]]></title>
        <link href="http://yoshitsugufujii.github.io/blog/2015/04/22/bootstrap-datetimepicker/"/>
        <updated>2015-04-22T21:52:21+09:00</updated>
        <id>http://yoshitsugufujii.github.io/blog/2015/04/22/bootstrap-datetimepicker</id>
        <content type="html"><![CDATA[<p>普段はよく<a href="https://github.com/eternicode/bootstrap-datepicker">bootstrap-datepicker</a>を使うのですが、
今回の案件では時刻まで絞り込みたいというお話だったのでdatetimepickerを導入してみました。</p>

<p>こちらを使います。かなり高機能な上に日本語化まで対応できる優れもの。<br/>
<a href="http://eonasdan.github.io/bootstrap-datetimepicker/">Eonasdan/bootstrap-datetimepicker</a></p>

<p>デモを見るだけでもワクワクしますね。<br/>
<a href="http://eonasdan.github.io/bootstrap-datetimepicker/Installing/">入れ方</a>もたくさん用意されていていいですね。<br/>
今回もrails-assetsで導入します。</p>

<!-- more -->


<pre><code class="ruby Gemfile">source 'https://rails-assets.org' do
  gem 'rails-assets-bootstrap-sass-official'
  gem 'rails-assets-eonasdan-bootstrap-datetimepicker'
end
</code></pre>

<p><code>bundle install</code>したら次はapp/assets/javascripts/application.jsに以下を記述。<br/>
日本語化する場合はmomentも一緒にいれます。</p>

<pre><code class="js app/assets/javascripts/application.js">//= require bootstrap-sass-official
//= require moment
//= require moment/locale/ja
//= require eonasdan-bootstrap-datetimepicker
</code></pre>

<p>最後にcssの読み込み<br/>
<code>css app/assets/stylesheets/application.css.scss
@import "bootstrap-sass-official";
@import "eonasdan-bootstrap-datetimepicker";
</code></p>

<p>これで設定は終了です。<br/>
あとはhtmlで</p>

<pre><code class="html">&lt;input class="datetimepicker form-control" type="text"&gt;
</code></pre>

<p>とかやって</p>

<pre><code class="js">  $(".datetimepicker").datetimepicker({
    format: "YYYY/MM/DD HH:mm",
    showClear: true,
    showClose: true,
    locale: 'ja'
   });
</code></pre>

<p>とかやると日本語かされた時刻も選択可能なカレンダーがいい感じに表示されるはずです。</p>

<h3>2014/04/25追記</h3>

<p>ちなみに書式設定をいじれば時刻選択なしの日付のみのdatepickerとしても使えます。</p>

<pre><code class="js">  $(".datepicker").datetimepicker({
    format: "YYYY/MM/DD",
    showClear: true,
    showClose: true,
    locale: 'ja'
   });
</code></pre>

<p>非常にいいですね。</p>
]]></content>
    </entry>
    
    <entry>
        <title type="html"><![CDATA[Railsでbootswatch導入(with rails assets)]]></title>
        <link href="http://yoshitsugufujii.github.io/blog/2015/04/16/bootswatch-with-rails-assets/"/>
        <updated>2015-04-16T11:01:57+09:00</updated>
        <id>http://yoshitsugufujii.github.io/blog/2015/04/16/bootswatch-with-rails-assets</id>
        <content type="html"><![CDATA[<p>管理画面を作るにあたって<a href="http://getbootstrap.com/">bootstrap</a>だけで1から作るのもしんどかったので、フリーのbootstrap用テンプレート<a href="https://bootswatch.com/">bootswatch</a>を使って管理画面を作ってみたいと思います。</p>

<p>導入には以下4パターンがあるかと思います。</p>

<ol>
<li><a href="https://github.com/maxim/bootswatch-rails">bootswatch-rails</a>などのGemを使う</li>
<li>bowerで入れる</li>
<li>rails-assetsで入れる</li>
<li>サイトからダウンロードしてassets下に配置する</li>
</ol>


<p>今回はrails-assetsで導入してみました。</p>

<!-- more -->


<p><a href="https://rails-assets.org/">Rails Assets</a>で検索するといくつか候補が出てきます。<br/>
今回はrails-assets-bootswatch-sassを使ってみます</p>

<pre><code class="ruby Gemfile">source 'https://rails-assets.org' do
  gem 'rails-assets-bootstrap-sass-official'
  gem 'rails-assets-bootswatch-sass'
end
</code></pre>

<p>そしてapplication.cssをapplication.css.scssにリネームして以下を追加です。</p>

<pre><code class="css app/assets/stylesheets/application.css.scss">$icon-font-path: "bootstrap-sass-official/";

@import "bootstrap-sass-official";
@import "bootswatch-sass/flatly/variables";
@import "bootswatch-sass/flatly/bootswatch";
@import "bootswatch-sass/flatly/bootstrap";
</code></pre>

<p>これでサイトがbootswatchのテーマが適用された状態(今回はフラットデザインのflatlyを選びました)となります。
簡単ですね。</p>
]]></content>
    </entry>
    
</feed>
