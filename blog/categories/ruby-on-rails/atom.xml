<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

    <title><![CDATA[Category: ruby on rails | なんとなく日々徒然と]]></title>
    <link href="http://yoshitsugufujii.github.io/blog/categories/ruby-on-rails/atom.xml" rel="self"/>
    <link href="http://yoshitsugufujii.github.io/"/>
    <updated>2018-02-14T19:32:13+09:00</updated>
    <id>http://yoshitsugufujii.github.io/</id>
    <author>
        <name><![CDATA[Yoshitsugu Fujii]]></name>
        
      </author>
    <generator uri="http://octopress.org/">Octopress</generator>

    
    <entry>
        <title type="html"><![CDATA[S3に直接にファイルアップロード]]></title>
        <link href="http://yoshitsugufujii.github.io/blog/2018/02/14/direct-upload-to-s3-with-rails-and-carrierwave/"/>
        <updated>2018-02-14T18:35:13+09:00</updated>
        <id>http://yoshitsugufujii.github.io/blog/2018/02/14/direct-upload-to-s3-with-rails-and-carrierwave</id>
        <content type="html"><![CDATA[<p>Herokuでの大きいファイルアップロードはリクエストタイムアウトが30秒に設定されているのでやっかいです。</p>

<p>Herokuの公式でも4MBを超えるファイルをあげる場合はS3に直接あげてねって書いてあります。<br/>
<a href="https://devcenter.heroku.com/articles/s3#direct-upload">https://devcenter.heroku.com/articles/s3#direct-upload</a></p>

<pre><code>This is the preferred approach if you’re working with file uploads bigger than 4MB. The idea is to skip the hop to your dyno, making a direct connection from the end user browser to S3. While this reduces the processing required by your application it is a more complex implementation and limits the ability to modify (transform, filter, resize etc…) the file before storing in S3.
</code></pre>

<p>carriwaveを使っているのでcarriwave_directいいなと思いましたが、<br/>
<a href="https://github.com/dwilkie/carrierwave_direct">carrierwave_direct</a></p>

<p>最終更新日が結構前でメンテされていないのかな？ってのとgemを使いすぎるとわけわかめになるので自力でやることにしました。</p>

<!-- more -->


<p></p>

<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p>  <br/>
<ins class="adsbygoogle"  
     style="display:block; text-align:center;"  
     data-ad-layout="in-article"  
     data-ad-format="fluid"  
     data-ad-client="ca-pub-7039502723411845"  
     data-ad-slot="8206045005"></ins></p>

<script>    
     (adsbygoogle = window.adsbygoogle || []).push({});    
</script>


<p></p>

<p>署名付きアップロード用のリンクを生成してjsに渡しjsでそのurlにアップロードする流れです。</p>

<p>Awsコンソールにログインしてs3からBucketを作成します。<br/>
作成したBucketを選択してアクセス権限タブからCORSの設定を開きます。<br/>
以下のように設定します。</p>

<pre><code>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;CORSConfiguration xmlns="http://s3.amazonaws.com/doc/2006-03-01/"&gt;
&lt;CORSRule&gt;
    &lt;AllowedOrigin&gt;*&lt;/AllowedOrigin&gt;
    &lt;AllowedMethod&gt;GET&lt;/AllowedMethod&gt;
    &lt;AllowedMethod&gt;PUT&lt;/AllowedMethod&gt;
    &lt;MaxAgeSeconds&gt;3000&lt;/MaxAgeSeconds&gt;
    &lt;AllowedHeader&gt;*&lt;/AllowedHeader&gt;
&lt;/CORSRule&gt;
&lt;/CORSConfiguration&gt;
</code></pre>

<p>次にGemfileに追記してbundle install</p>

<pre><code class="ruby"># Gemfile
gem 'aws-sdk'
</code></pre>

<p>S3_BUCKETを操作できるようにします。</p>

<pre><code class="ruby"># config/initializers/aws.rb
credentials = Aws::Credentials.new(
  ENV[:aws_access_key],
  ENV[:aws_secret]
)

s3_resource = Aws::S3::Resource::new(region: 'bucketのregion', credentials: credentials)
S3_BUCKET = s3_resource.bucket('bucket名')
</code></pre>

<p>URL生成のメソッドはCarrierwaveのuploaderクラスにメソッド生やしました。<br/>
取得はそのままCarrierwaveを使うイメージです。<br/>
今のプロジェクトでは基底クラスを作ってそれを継承させてます。</p>

<pre><code class="ruby">class ApplicationUploader &lt; CarrierWave::Uploader::Base
  def store_dir
    "uploads/#{model.class.to_s.underscore}/#{mounted_as}/#{model.id}"
  end

  def presigned_url(file_name = nil)
    file_name ||= self.model.attributes[mounted_as.to_s]
    object = S3_BUCKET.object([store_dir, file_name].join('/'))
    object.presigned_url(:put, expires_in: 1.minutes.to_i, acl: 'private')
  end
end

class ImageUploader &lt; ApplicationUploader
end
</code></pre>

<p>これで以下のように署名付きリンクを生成できます。</p>

<pre><code>user = User.find(1)
user.image.presigned_url # =&gt; 署名付きのs3直アップロードurl
</code></pre>

<p>署名付きリンクはデフォルトで900秒（15分）で失効します(上記uploaderでは1分にしている)<br/>
そのためcontrollerに生成してhiddenとかgonで渡すのはやめたほうがいい気がします。</p>

<p>jsで署名付きリンク生成リクエストをもらってurlを返し、そのurlでs3にアップロードするようにします。</p>

<p>Grapeでapiを作ります。</p>

<pre><code>params do
  requires :file_name, type: String, desc: 'ファイル名'
end
post do
  user = User.create
  user.update_column('image', params[:file_name])
  {id: user.id, filename: params[:file_name], url: user.image.presigned_url}
end
</code></pre>

<p>carriwaveで処理させたいのですがstore先にidが必要なため保存しています。</p>

<p>以下リンク取得からアップロードまでのサンプルです。<br/>
ちょっと適当な部分があるので動かなかったらすいません。</p>

<pre><code class="js">let fd = new FormData();
fd.append('file', $('.file'));

$.ajax({
  url : 'grapeのurl',
  data : {file_name: fileData.get('file').name},
  type : 'post',
  dataType : 'json'
}).then(function(data) {
  $.ajax({
    url : data.url,
    data : fileData.get('file'),
    type : 'put',
    dataType : 'xml',
    processData : false,
    contentType : false,
    success : function(){
      console.log('成功したよー');
    },
    error : function(){
      console.log('失敗。無念');
    }
  });
});
</code></pre>

<p>carrierwave-attachmentscannerを使っていたんですが、これは直アップロードだと使えないので、保存と同時にafter_saveでsidekiqのキューに押し込んであとでウィルスチェックしています。</p>
]]></content>
    </entry>
    
    <entry>
        <title type="html"><![CDATA[carrierwaveのリンクの有効期間を個別に設定]]></title>
        <link href="http://yoshitsugufujii.github.io/blog/2018/02/09/carrierwave-expire-setting/"/>
        <updated>2018-02-09T19:27:03+09:00</updated>
        <id>http://yoshitsugufujii.github.io/blog/2018/02/09/carrierwave-expire-setting</id>
        <content type="html"><![CDATA[<p>全体でかける場合はこうですかね。</p>

<pre><code class="ruby"># config/initializers/carrierwave.rb
CarrierWave::SanitizedFile.sanitize_regexp = /[^[:word:]\.\-\+]/ # for Japanese
CarrierWave.configure do |config|
  config.fog_credentials = {
    provider:              'AWS',
    aws_access_key_id:     ENV[:access_key],
    aws_secret_access_key: ENV[:secret],
    region:                ENV['s3_region']
  }

  config.fog_public = false
  config.fog_directory = Settings.aws['s3_bucket']
  config.cache_storage = :fog
  config.fog_authenticated_url_expiration = 1.minutes.to_i
end
</code></pre>

<!-- more -->


<p></p>

<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p>  <br/>
<ins class="adsbygoogle"  
     style="display:block; text-align:center;"  
     data-ad-layout="in-article"  
     data-ad-format="fluid"  
     data-ad-client="ca-pub-7039502723411845"  
     data-ad-slot="8206045005"></ins></p>

<script>    
     (adsbygoogle = window.adsbygoogle || []).push({});    
</script>


<p></p>

<p>個々のアップローダークラスでかける場合<br/>
<code>  
class ImageUploader &lt; CarrierWave::Uploader::Base  
  def fog_authenticated_url_expiration  
    1.minutes.to_i  
  end  
end  
</code><br/>
uploader内ではmodelでモデル側のインスタンスを参照できるのでmodel側の条件で動的に有効期限を変えるとかもできそうですね。</p>
]]></content>
    </entry>
    
    <entry>
        <title type="html"><![CDATA[ruby2.5にあげたら例外発生時にstacktraceが吐き出されなくなった]]></title>
        <link href="http://yoshitsugufujii.github.io/blog/2018/01/31/no-backtrace/"/>
        <updated>2018-01-31T11:51:51+09:00</updated>
        <id>http://yoshitsugufujii.github.io/blog/2018/01/31/no-backtrace</id>
        <content type="html"><![CDATA[<p>Railsである日を境に例外発生時にスタックトレースがでなくなっちゃいました。</p>

<pre><code>F, [2018-01-31T11:41:40.388898 #5662] FATAL -- : 
NoMethodError - undefined method `company_users' for nil:NilClass:
</code></pre>

<p>railsのlogにはこれしかでない。</p>

<!-- more -->


<p></p>

<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p>  <br/>
<ins class="adsbygoogle"  
     style="display:block; text-align:center;"  
     data-ad-layout="in-article"  
     data-ad-format="fluid"  
     data-ad-client="ca-pub-7039502723411845"  
     data-ad-slot="8206045005"></ins></p>

<script>    
     (adsbygoogle = window.adsbygoogle || []).push({});    
</script>


<p></p>

<p>検索すると発見。</p>

<p><a href="https://stackoverflow.com/questions/48327987/why-does-ruby-2-5-0-not-show-a-stacktrace-in-rails-5-1-4">Why does Ruby 2.5.0 not show a stacktrace in Rails 5.1.4?</a></p>

<p>なるほどrubyを2.5にあげたからか。</p>

<p>手元の環境を見ると</p>

<pre><code>ruby (2.5)  
rails (5.1.4)  
binding_of_caller (0.7.2)
</code></pre>

<p>0.8.0にbinding_of_callerにあげて解決です。</p>
]]></content>
    </entry>
    
    <entry>
        <title type="html"><![CDATA[国際化対応(お金関連)]]></title>
        <link href="http://yoshitsugufujii.github.io/blog/2018/01/30/money-localization/"/>
        <updated>2018-01-30T10:27:12+09:00</updated>
        <id>http://yoshitsugufujii.github.io/blog/2018/01/30/money-localization</id>
        <content type="html"><![CDATA[<p>国際化対応。<br/>
DBの日時はutcで保存して表示する時にユーザによって該当のタイムゾーンで表示とか色々な知見はあるかと思いますが。<br/>
お金の区切りもあるんですね。</p>

<!-- more -->


<p></p>

<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p>  <br/>
<ins class="adsbygoogle"  
     style="display:block; text-align:center;"  
     data-ad-layout="in-article"  
     data-ad-format="fluid"  
     data-ad-client="ca-pub-7039502723411845"  
     data-ad-slot="8206045005"></ins></p>

<script>    
     (adsbygoogle = window.adsbygoogle || []).push({});    
</script>


<p></p>

<p>お金ってカンマ区切りだけかと思い込んでましたがそうじゃないらしいです。</p>

<p><a href="http://coliss.com/articles/build-websites/operation/writing/53.html">世界各国での数字の区切り方</a></p>

<p>数値がペリオドで送られてくる国やスペースで送ってくる国があるので注意が必要です。<br/>
カンマ一括で消して処理していたらバリデーションで特定の国入力エラーになっていた。</p>

<p>jsのtoLocaleStringとか使うとドイツのブラウザではカンマではなくペリオド入るらしいので気をつけるべし</p>
]]></content>
    </entry>
    
    <entry>
        <title type="html"><![CDATA[Doorkeeperでパスワードが変更されたらクライアント側でログアウトさせる]]></title>
        <link href="http://yoshitsugufujii.github.io/blog/2018/01/29/logout-when-doorkeeper-password-change/"/>
        <updated>2018-01-29T14:26:19+09:00</updated>
        <id>http://yoshitsugufujii.github.io/blog/2018/01/29/logout-when-doorkeeper-password-change</id>
        <content type="html"><![CDATA[<p><a href="https://github.com/doorkeeper-gem/doorkeeper">Doorkeeper</a>を使ったoauthの仕組みでプラットフォーム側でパスワード変更の処理を書いててパスワード変更しても現在ログイン状態のユーザーがログアウトされなくて久しぶりにどっぷりハマったのでメモ。</p>

<!-- more -->


<p></p>

<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p>  <br/>
<ins class="adsbygoogle"  
     style="display:block; text-align:center;"  
     data-ad-layout="in-article"  
     data-ad-format="fluid"  
     data-ad-client="ca-pub-7039502723411845"  
     data-ad-slot="8206045005"></ins></p>

<script>    
     (adsbygoogle = window.adsbygoogle || []).push({});    
</script>


<p></p>

<p>セッションストアであるredisを見ると同じユーザーで二つのブラウザでログインすると２つ違うsession keyで保持されている。<br/>
このセッションの中身は</p>

<p>一つ目はwarden key(そのままだとユーザID)<br/>
二つ目はencrypted_password</p>

<p>となっているようだ。</p>

<p><a href="https://stackoverflow.com/a/23683925/2223472">https://stackoverflow.com/a/23683925/2223472</a></p>

<p>Doorkeeperを使っているクライアントではoauth認証を使うのでパスワードを使っていない<br/>
そのため二つめencrypted_passwordの値は空になっている。</p>

<p>この二つの値を使って認証しているようだ。</p>

<p>プラットフォーム側でパスワードを変更しても二つ目の値は相変わらず空のためクライアント側ではセッションの状況に変化なしとなり<br/>
そのままログインが保持されてしまう。</p>

<p>tokenを使ったりパスワードを渡す等があったりしたがこうした。</p>

<p>まず、 パスワード変更時刻をプラットフォーム側にcolumnとして追加。<br/>
パスワード変更時にupdateするようにする。</p>

<pre><code class="">class User &lt; ApplicationRecord  
  def reset_password(*args)  
    self.password_changed_at = Time.current  
    super  
  end  
end  
</code></pre>

<p>そしてクライアントサイドでは連携されたpassword_changed_atを使うようにする。</p>

<pre><code class="">class User &lt; ApplicationRecord  
  def authenticatable_salt  
    password_changed_at  
  end  
end  
</code></pre>

<p>これでパスワードが変更されるとクライアントのセッションの中身も変わり、<br/>
他のブラウザでログインしていても適切にログアウトされる。</p>
]]></content>
    </entry>
    
</feed>
