<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

    <title><![CDATA[Category: ruby on rails | なんとなく日々徒然と]]></title>
    <link href="http://yoshitsugufujii.github.io/blog/categories/ruby-on-rails/atom.xml" rel="self"/>
    <link href="http://yoshitsugufujii.github.io/"/>
    <updated>2015-06-11T14:49:51+09:00</updated>
    <id>http://yoshitsugufujii.github.io/</id>
    <author>
        <name><![CDATA[Yoshitsugu Fujii]]></name>
        
      </author>
    <generator uri="http://octopress.org/">Octopress</generator>

    
    <entry>
        <title type="html"><![CDATA[simple_formで表示されるエラーをfull_messagesのものにする]]></title>
        <link href="http://yoshitsugufujii.github.io/blog/2015/06/11/simple-form-error-full-message/"/>
        <updated>2015-06-11T14:30:19+09:00</updated>
        <id>http://yoshitsugufujii.github.io/blog/2015/06/11/simple-form-error-full-message</id>
        <content type="html"><![CDATA[<pre><code class="ruby">#開発環境
rails (4.2.1)
simple_form (3.1.0)
</code></pre>

<p>simple_formをそのまま使うとエラー発生時のエラーの表示がfull_messageではなく、object.errors[:name]みたいにした時の値しか表示してくれない。</p>

<p>こんな感じ。<br/>
<img src="/images/blog/simple_form_error2015-06-10.png" alt="normal error" /></p>

<p>ちょっとこれだとあんまりなのでfull_messageでメッセージを表示したい</p>

<!-- more -->


<p>この<a href="https://github.com/plataformatec/simple_form/issues/989">issue</a>でこの問題にパッチを当てている人がいたのでそのままパクらせていただきます。</p>

<p>こうするだけ<br/>
<code>ruby config/initializer/simple_form_error_path.rb
module SimpleForm::Components::Errors
  def errors_on_attribute
    object.errors.full_messages_for(attribute_name)
  end
end
</code></p>

<p>するとこうなります。<br/>
<img src="/images/blog/simple_form_full_error2015-06-10.png" alt="full error" /><br/>
いい感じですね。</p>
]]></content>
    </entry>
    
    <entry>
        <title type="html"><![CDATA[railsでuser_idをurlに付与して引き回す方法]]></title>
        <link href="http://yoshitsugufujii.github.io/blog/2015/06/10/append-user-id-to-url/"/>
        <updated>2015-06-10T12:01:49+09:00</updated>
        <id>http://yoshitsugufujii.github.io/blog/2015/06/10/append-user-id-to-url</id>
        <content type="html"><![CDATA[<p>特定のパラメータを常にurlに付与する方法です。</p>

<p>urlにuser_idをクエリなどにふくめておくとgoogle analyticsとか使った時に、特定のユーザがどういうページにアクセスしたかわかりユーザの行動分析に使えたりします。</p>

<p>なのでurlに自動でuser_id=[:user_id]の形式でアクセスしてるページのuser_idが付与されると非常に便利そうです。</p>

<p>参考になったのはjpmobileのソースでした(docomo端末の場合にguidを自動付与したりしています)<br/>
<a href="https://github.com/jpmobile/jpmobile/blob/master/lib/jpmobile/docomo_guid.rb">docomo_guid.rb</a></p>

<!-- more -->


<p>こうすれば自動でユーザーIDが設定されます。</p>

<pre><code class="ruby app/controller/application_controller.rb ">class ApplicationController &lt; ActionController::Base
  def default_url_options
    result = super || {}
    if current_user.present?
      result.merge!(user_id: current_user.id)
    else
      result.delete(:user_id)
    end
    result
  end
end
</code></pre>

<p>これでログインしていれば(上記だとcurrent_userが取れれば)<br/>
<a href="http://localhost:3000/?user_id=6">http://localhost:3000/?user_id=6</a><br/>
みたいに付与されるはずです。</p>

<p>今やっている案件でこの処理が必要になったので思い出しながら書いてみましたが、以前これを利用して遷移前の履歴をurlに保持するgemを作ったことをふと思いだしました。<br/>
<a href="https://github.com/YoshitsuguFujii/light_stalking">light_stalking</a></p>

<p>このGEMは思いつきで作って実際に使ってないので色々と問題ありそうですが、default_url_optionsを使うことでurlの最大長にひっかからない範囲で色々なことができそうという一例になるんじゃないかと思いました。</p>
]]></content>
    </entry>
    
    <entry>
        <title type="html"><![CDATA[Deviseで特定の条件のみパスワードの検証をスキップする]]></title>
        <link href="http://yoshitsugufujii.github.io/blog/2015/06/08/devise-skip-password-check/"/>
        <updated>2015-06-08T12:35:01+09:00</updated>
        <id>http://yoshitsugufujii.github.io/blog/2015/06/08/devise-skip-password-check</id>
        <content type="html"><![CDATA[<pre><code class="ruby">#開発環境  
rails 4.2.1  
devise 3.4.1  
</code></pre>

<p>deviseを使っていて、ユーザモデルに仮登録状態を作りたいと思います。<br/>
仮登録の段階ではパスワードはまだ要求されず。<br/>
最後の最後でパスワードを設定して本会員登録完了といったフローです。</p>

<p>deviseでは対象モデルに<code>devise :validatable</code>に設定している場合はメールアドレスやパスワードの検証が走ります。<br/>
今回はパスワード以外のチェックはやってほしいため<code>:validatable</code>の宣言を外すだけではダメです。</p>

<!-- more -->


<p>deviseの以下のソースを見てみます</p>

<pre><code class="ruby lib/devise/models/validatable.rb">def self.included(base)
  base.extend ClassMethods
  assert_validations_api!(base)

  base.class_eval do
    validates_presence_of   :email, if: :email_required?
    validates_uniqueness_of :email, allow_blank: true, if: :email_changed?
    validates_format_of     :email, with: email_regexp, allow_blank: true, if: :email_changed?

    validates_presence_of     :password, if: :password_required?
    validates_confirmation_of :password, if: :password_required?
    validates_length_of       :password, within: password_length, allow_blank: true
  end
end
</code></pre>

<p>パスワードの検証をするかどうかはpassword_required?で判定しています。
判定メソッドはこんな感じです。</p>

<pre><code class="ruby">def password_required?
  !persisted? || !password.nil? || !password_confirmation.nil?
end
</code></pre>

<p>これを対象のモデルでオーバーライドします。</p>

<pre><code class="ruby">class User &lt; ActiveRecord::Base

  devise :database_authenticatable, :registerable,
         :recoverable, :rememberable, :trackable, :validatable

  def password_required?
    if member?
      !persisted? || !password.nil? || !password_confirmation.nil?
    else
      false
    end
  end
end
</code></pre>

<p>これでmember?がtrueを返さない(本登録前のユーザ)はパスワードの検証処理をスキップできるようになります。</p>
]]></content>
    </entry>
    
    <entry>
        <title type="html"><![CDATA[モデルのattributeに変更がなくてもnested_attribute_forを使っているモデルでcallbackを発生させる]]></title>
        <link href="http://yoshitsugufujii.github.io/blog/2015/05/25/force-occur-callbacks/"/>
        <updated>2015-05-25T16:15:38+09:00</updated>
        <id>http://yoshitsugufujii.github.io/blog/2015/05/25/force-occur-callbacks</id>
        <content type="html"><![CDATA[<p>任意の条件でnested_attribute_forの対象の保存処理を走らせる方法です</p>

<p>ファイルのアップロード用のモデルを作っていて<code>ActionDispatch::Http::UploadedFile</code>を一旦attr_accessorのアクセサで受けたあとcallbackでファイル名やファイルサイズをmodelクラスの該当のカラムに設定するという処理を書いておりました。</p>

<p>ファイルは可変にアップロードしたかったのでこのモデルの親モデルから参照するようにして、nested_attribute_forで親モデル更新時に一緒に更新するようにします。</p>

<pre><code class="ruby">class Oya &lt; ActiveRecord::Base
  has_many :files, dependent: :destroy

  accepts_nested_attributes_for :files, allow_destroy: true
end
</code></pre>

<pre><code class="ruby">class File &lt; ActiveRecord::Base
  attr_accessor :file
end
</code></pre>

<!-- more -->


<p>いらない情報ですが、一応モデルクラスFileモデルの参照先のテーブルfilesテーブルはこんな感じです。
<code>ruby
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `created_at` datetime DEFAULT NULL,
  `updated_at` datetime DEFAULT NULL,
  `oya_id` int(11) NOT NULL,
  `data_file_name` varchar(255) DEFAULT NULL,
  `data_content_type` varchar(255) DEFAULT NULL,
  `data_file_size` int(11) DEFAULT NULL,
</code></p>

<p>新規登録の時は良かったんですが、親モデル保存時にnested_attribute_forの対象のモデルクラスのsave(auto_save)やcallbackを走らせるかどうかは実際にデータベースに登録されているカラムの値に変化があったかで決定されているようです(たぶん)</p>

<p>そのため変更時にはformからはfileというアクセサに設定する値のみ飛んでくるような作りだとauto_saveが動かずFileクラスの更新処理が走りませんでした。</p>

<p>そのためchanged_for_autosave?をオーバーライドすることで独自に変更判定を行いcallback並びにauto saveが動くようにします。</p>

<pre><code class="ruby">class File &lt; ActiveRecord::Base
  attr_accessor :file

  def changed_for_autosave?
    if file.present?
      return true
    end
    super
  end
end
</code></pre>

<p>知ってると簡単ですが、知らないとはまりますね。</p>
]]></content>
    </entry>
    
    <entry>
        <title type="html"><![CDATA[nested_formで下じゃなくて上に要素を追加したい場合]]></title>
        <link href="http://yoshitsugufujii.github.io/blog/2015/05/20/nested-form-add-field-to-top/"/>
        <updated>2015-05-20T18:03:26+09:00</updated>
        <id>http://yoshitsugufujii.github.io/blog/2015/05/20/nested-form-add-field-to-top</id>
        <content type="html"><![CDATA[<p>neste_formは可変なサイズの子要素を動的に追加できるGemです。</p>

<p><a href="https://github.com/ryanb/nested_for://github.com/ryanb/nested_form">nested form</a></p>

<p>いつも大変お世話になっておりますが、今回の案件で追加する先を指定したエレメントの下ではなく上に追加しなければいけなくなり対応しました。</p>

<!-- more -->


<p>バージョンは<br/>
<code>ruby Gemfile.lock
nested_form (0.3.2)  
</code>
での作業となります。</p>

<p>ますnested_formで使われるjsを眺めるとそんなに長くない処理であることがわかります。<br/>
その中で追加ボタンを押したときに要素を追加する部分はこの辺りになるようです。</p>

<pre><code class="js jquery_nested_form:55行目あたり">    insertFields: function(content, assoc, link) {
      var target = $(link).data('target');
      if (target) {
        return $(content).appendTo($(target));
      } else {
        return $(content).insertBefore(link);
      }
    },
</code></pre>

<p>ここを上書きします。 <br/>
application.jsで<code>//= require jquery_nested_form</code>の後に以下の処理を書いて上書きしちゃいましよう。</p>

<pre><code class="js">window.NestedFormEvents.prototype.insertFields = function(content, assoc, link) {
  var target = $(link).data('target');
  if ($(link).data('destination') == "prepend"){
    return $(target).prepend($(content));
  }else{
    if (target) {
      return $(content).appendTo($(target));
    } else {
      return $(content).insertBefore(link);
    }
  }
}
</code></pre>

<p>linkのdata-destination=prependで対象の要素の上にprependで追加されるイメージです。</p>

<p>&#8220;`erb</p>

<table id="tasks">
  <%= f.fields_for :tasks, :wrapper => false do |task_form| %>
    <tr class="fields">
      <td><%= task_form.text_field :name %></td>
      <td><%= task_form.link_to_remove "Remove this task" %></td>
    </tr>
  <% end %>
</table>


<p><p>&lt;%= f.link_to_add &ldquo;Add a task&rdquo;, :tasks, :data => { :target => &ldquo;#tasks&rdquo;, :prepend => true } %></p>
&#8220;`</p>

<p>簡単でした。</p>
]]></content>
    </entry>
    
</feed>
