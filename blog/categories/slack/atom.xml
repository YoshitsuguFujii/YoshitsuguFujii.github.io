<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

    <title><![CDATA[Category: slack | なんとなく日々徒然と]]></title>
    <link href="http://yoshitsugufujii.github.io/blog/categories/slack/atom.xml" rel="self"/>
    <link href="http://yoshitsugufujii.github.io/"/>
    <updated>2021-02-02T15:39:23+09:00</updated>
    <id>http://yoshitsugufujii.github.io/</id>
    <author>
        <name><![CDATA[Yoshitsugu Fujii]]></name>
        
      </author>
    <generator uri="http://octopress.org/">Octopress</generator>

    
    <entry>
        <title type="html"><![CDATA[Go言語を使ってローカルマシン上でbotを動かしSlackでtodo管理をする]]></title>
        <link href="http://yoshitsugufujii.github.io/blog/2015/11/10/slack-todo-bot/"/>
        <updated>2015-11-10T20:29:05+09:00</updated>
        <id>http://yoshitsugufujii.github.io/blog/2015/11/10/slack-todo-bot</id>
        <content type="html"><![CDATA[<p>前回の続編です。</p>

<p><a href="http://yoshitsugufujii.github.io/blog/2015/09/04/golang-bot-for-slack/">Go言語を使ってローカルマシンに簡易botを作ってSlackに投稿</a></p>

<p>botを使ったtodo機能をslackに付与するべくgoのコードを書いてみました。</p>

<p><code>todo コマンド {{追加削除の場合はテキスト}}</code></p>

<p>という感じでつぶやくと、</p>

<p>チャンネル毎にtodoリストが管理できるようにしたいと思います。<br/>
dbがなくても動くようにファイルに保存します。</p>

<table>
<thead>
<tr>
<th style="text-align:left;">操作</th>
<th style="text-align:left;">コマンド</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">追加</td>
<td style="text-align:left;"> add 追加したいテキスト </td>
</tr>
<tr>
<td style="text-align:left;">削除</td>
<td style="text-align:left;"> del 削除したいテキスト </td>
</tr>
<tr>
<td style="text-align:left;">一覧</td>
<td style="text-align:left;"> list </td>
</tr>
<tr>
<td style="text-align:left;">全削除</td>
<td style="text-align:left;"> clear </td>
</tr>
</tbody>
</table>


<p>こんな感じで動きます。</p>

<p><img src="/images/blog/todo_bot_sample.gif" alt="todobot" /></p>

<p>便利そうですね！</p>

<!-- more -->


<p>まずはslacbot.goにmainの処理を書いていきます。</p>

<pre><code class="go ">package main

import (
    "./todo_list"
    "fmt"
    "net/http"
)

var p = fmt.Println

func todoListBot(w http.ResponseWriter, r *http.Request) {
    checkUser(w, r, func(text string, channel_name string) {
        return_text := todo.Accept(text, channel_name)
        fmt.Fprintf(w, "{\"text\": \"%s\"}", return_text)
    })
}

func checkUser(w http.ResponseWriter, r *http.Request, proc func(text string, channel_name string)) {
    if r.Method == "POST" {
        text := r.FormValue("text")
        user_name := r.FormValue("user_name")
        channel_name := r.FormValue("channel_name")

        if user_name != "slackbot" {
            p("user_name:", user_name)
            p("channel_name:", channel_name)
            proc(text, channel_name)
        }
    }
}

func main() {
    http.HandleFunc("/todo", todoListBot)
    http.ListenAndServe(":8888", nil)
}
</code></pre>

<p>続いて実装です。<br/>
一段階層を下げます。<br/>
todo_listというディレクトリを作ってそこにtodo.goを置きます。</p>

<pre><code class="go ">package todo

import (
    "../util"
    "fmt"
    "io/ioutil"
    "log"
    "os"
    "strings"
)

const ADD = "add"
const DEL = "del"
const LIST = "list"
const CLEAR = "clear"
const STORE_DIR = "todo_list/stored_files"

var p = fmt.Println

func Accept(text string, channel_name string) string {
    var command string
    var message string
    var rtn_text string

    if validateParams(text) {
        command, message = parseText(text)
    } else {
        return "入力されたパラメータが不正です→ " + text
    }

    if command == ADD {
        rtn_text = add(channel_name, message)
    } else if command == DEL {
        rtn_text = del(channel_name, message)
    } else if command == LIST {
        rtn_text = list(channel_name)
    } else if command == CLEAR {
        rtn_text = clear(channel_name)
    }

    return rtn_text
}

func validateParams(text string) bool {
    var command string

    if len(strings.Split(text, " ")) &lt; 2 {
        return false
    }

    command = getCommand(text)
    correct_commands := []string{ADD, LIST, DEL, CLEAR}
    if !util.Contains(correct_commands, command) {
        return false
    }

    return true
}

func parseText(text string) (command string, post_text string) {
    command = getCommand(text)
    post_text = getMessage(text)
    return
}

func getTriggerWord(text string) string {
    return strings.Split(text, " ")[0]
}

func getCommand(text string) string {
    return strings.Split(text, " ")[1]
}

func getMessage(text string) string {
    if len(strings.Split(text, " ")) &gt; 2 {
        return strings.Split(text, " ")[2]
    } else {
        return ""
    }
}

func add(channel_name string, message string) string {
    // ディレクトリの作成
    err := os.MkdirAll(STORE_DIR, 0777)
    if err != nil {
        util.Perror(err)
    }

    file_path := getStoredPath(channel_name)
    // ファイルがなかったら作る
    if !util.FileExists(file_path) {
        util.CreateFile(file_path)
    }
    f, err := os.OpenFile(file_path, os.O_APPEND|os.O_WRONLY, 0600)

    if err != nil {
        return "ファイルのオープンに失敗しました"
    }
    defer f.Close()

    message = strings.Replace(message, "\n", " ", -1)
    if _, err = f.WriteString(message + "\n"); err != nil {
        return "書き込みに失敗しました"
    }

    lines, _ := getList(file_path)
    return "登録に成功しました :wink: \n 現在のタスク \n- " + strings.Join(lines, "\n- ")
}

func list(channel_name string) string {
    file_path := getStoredPath(channel_name)

    if !util.FileExists(file_path) {
        return "まだ何も書き込まれていません"
    }

    lines, _ := getList(file_path)

    return "現在のタスクです。\n気張っていきましょー :kissing_heart: \n\n- " + strings.Join(lines, "\n- ")
}

func del(channel_name string, message string) string {
    var del_flg bool
    var new_lines []string
    message = strings.Replace(message, "\n", " ", -1)
    file_path := getStoredPath(channel_name)

    if !util.FileExists(file_path) {
        return "まだ何も書き込まれていません"
    }

    lines, err := util.ReadLines(file_path)
    if err != nil {
        log.Fatalf("readLines: %s", err)
    }

    for i := 0; i &lt; len(lines); i++ {
        if lines[i] == message {
            del_flg = true
        }

        if lines[i] != message {
            new_lines = append(new_lines, lines[i])
        }
    }

    if del_flg {
        if len(new_lines) == 0 {
            if err := os.Remove(file_path); err != nil {
                return "クリアに失敗しました"
            }
        } else {
            content := []byte(strings.Join(new_lines, "\n") + "\n")
            ioutil.WriteFile(file_path, content, 0600)
        }

        if len(new_lines) != 0 {
            lines, _ = getList(file_path)
        }
        return "削除に成功しました :neutral_face: \n 残りのタスク \n- " + strings.Join(lines, "\n- ")
    } else {
        return "一致するものが見つかりませんでした"
    }
}

func clear(channel_name string) string {
    file_path := getStoredPath(channel_name)
    if err := os.Remove(file_path); err != nil {
        return "クリアに失敗しました"
    }

    return "クリアしました"
}

func getStoredPath(channel_name string) string {
    return STORE_DIR + "/" + channel_name
}

func getList(file_path string) ([]string, error) {
    lines, err := util.ReadLines(file_path)
    if err != nil {
        log.Fatalf("readLines: %s", err)
    }

    return lines, err
}
</code></pre>
]]></content>
    </entry>
    
    <entry>
        <title type="html"><![CDATA[Go言語を使ってローカルマシンに簡易botを作ってSlackに投稿]]></title>
        <link href="http://yoshitsugufujii.github.io/blog/2015/09/04/golang-bot-for-slack/"/>
        <updated>2015-09-04T17:17:58+09:00</updated>
        <id>http://yoshitsugufujii.github.io/blog/2015/09/04/golang-bot-for-slack</id>
        <content type="html"><![CDATA[<p>Goを勉強がてら使いながら簡易slackbotを作ってみました。<br/>
slackにデフォルトで用意されているslackbotってお願いしますをキーに登録すると、「お願いします]
とか「お願いします。」(句読点入り)は反応してくれるけど。 「よろしくお願いします。」みたいに単語をつなげると反応してくれない。</p>

<p>単純に単語が含まれるかだけで反応してくれればいいのに・・・</p>

<p>ということもありお手製slackbotをつくってみました。<br/>
自分のPCでプログラムを動かし、slackで投稿があった際にはOutgoing WebHooksで投稿内容を取得してBotとして返信したいと思います。</p>

<p>slack → ローカルmacのbot → slack</p>

<p>の流れです。</p>

<!-- more -->


<p>まずは外から自分のmacを見つけてもらうためにngrokにトンネルしてもらいましょう。<br/>
ngrokの設定とか概要はこちらを見てださい。<br/>
<a href="http://qiita.com/kitaro729/items/44214f9f81d3ebda58bd">ngrokを使用してローカル環境を外部に公開する</a><br/>
普段から最高にお世話になっているサービスです。</p>

<p>Slackの設定です。WebでSlackを開き左のMenuからIntegrationsを選びAll Servicesタブの中からOutgoing WebHooksを選択します。<br/>
新規作成画面のURL(s)にngrokで接続できるurlを設定します。<br/>
channelは新規でtestを。<br/>
Customeize NameにはBotが発言した時の名前が、Cutomize IconにはBotが発言した時のアイコンが設定できます。</p>

<p>これでslackの設定は完了です。</p>

<p>次にgoのプロググラムを動かします。<br/>
もしgoがインストールされてなかったらここ見るといいです。<br/>
<a href="http://qiita.com/morisuke/items/ce04479c1b26d83f4fe3">Golang開発環境 3分クッキング</a><br/>
あとyamlを使うのでyamlのライブラリもいれます。</p>

<pre><code>go get gopkg.in/yaml.v2
</code></pre>

<p>goのソースはこんな感じ
```go
package main</p>

<p>import (
    &ldquo;fmt&rdquo;
    &ldquo;gopkg.in/yaml.v2&rdquo;
    &ldquo;io/ioutil&rdquo;
    &ldquo;math/rand&rdquo;
    &ldquo;net/http&rdquo;
    &ldquo;strings&rdquo;
    &ldquo;time&rdquo;
)</p>

<p>const WordTable = &ldquo;word.yml&rdquo;</p>

<p>var p = fmt.Println</p>

<p>func Serve(w http.ResponseWriter, r *http.Request) {
    if r.Method == &ldquo;POST&rdquo; {
        text := r.FormValue(&ldquo;text&rdquo;)
        user_name := r.FormValue(&ldquo;user_name&rdquo;)</p>

<pre><code>    if user_name != "slackbot" {
        p("user_name:", user_name)
        return_text := detect_word(text)
        fmt.Fprintf(w, "{\"text\": \"%s\"}", return_text)
    }
}
</code></pre>

<p>}</p>

<p>func getWordTable() map[string][]string {
    buf, err := ioutil.ReadFile(WordTable)
    if err != nil {
        panic(err)
    }</p>

<pre><code>m := make(map[string][]string)
err = yaml.Unmarshal(buf, &amp;m)
if err != nil {
    panic(err)
}

return m
</code></pre>

<p>}</p>

<p>func keys(words map[string][]string) []string {
    var keys []string</p>

<pre><code>for key, _ := range words {
    keys = append(keys, key)
}
return keys
</code></pre>

<p>}</p>

<p>func detect_word(post_text string) (bot_message string) {
    dict := getWordTable()  // 設定を取得
    word_keys := keys(dict) // キーのみ抽出
    var suggestion []string</p>

<pre><code>for i := 0; i &lt; len(word_keys); i++ {
    if strings.Contains(post_text, word_keys[i]) {
        suggestion = append(suggestion, dict[word_keys[i]]...)
    }
}

if len(suggestion) &gt; 0 {
    rand.Seed(time.Now().UnixNano())
    bot_message = suggestion[rand.Intn(len(suggestion))]
}
return bot_message
</code></pre>

<p>}</p>

<p>func main() {
    http.HandleFunc(&ldquo;/&rdquo;, Serve)
    http.ListenAndServe(&ldquo;:8080&rdquo;, nil)
}
```</p>

<p>プログラムの中でソースと同一ディレクトリにあるword.ymlを読み出しています。<br/>
これはslackでの発言と反応をまとめたyamlファイルです。<br/>
発言にひっかけたい文字列をキーに、反応を配列形式で設定します。<br/>
こんな感じです。</p>

<pre><code class="yaml">お願いします:
  - こちらこそよろしく頼む
  - えーっ、やだよ
よろしいでしょうか: &amp;yoro
  - 許さん
  - 金による

いいですか:
  *yoro
</code></pre>

<p>では<code>fresh</code>起動しましょう。<br/>
testチャンネルでつぶやいてみます。</p>

<p><img src="/images/blog/2015-09-04.png" alt="slackbot" /></p>

<p>おお、できました！<br/>
ゴルーチンとかチャネルとかまだあんまりよくわかってないので引き続き勉強していきたいと思います。</p>
]]></content>
    </entry>
    
</feed>
