<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

    <title><![CDATA[Category: ruby | なんとなく日々徒然と]]></title>
    <link href="http://yoshitsugufujii.github.io/blog/categories/ruby/atom.xml" rel="self"/>
    <link href="http://yoshitsugufujii.github.io/"/>
    <updated>2015-06-08T12:47:53+09:00</updated>
    <id>http://yoshitsugufujii.github.io/</id>
    <author>
        <name><![CDATA[Yoshitsugu Fujii]]></name>
        
      </author>
    <generator uri="http://octopress.org/">Octopress</generator>

    
    <entry>
        <title type="html"><![CDATA[Deviseでパスワードの検証をスキップする]]></title>
        <link href="http://yoshitsugufujii.github.io/blog/2015/06/08/devise-skip-password-check/"/>
        <updated>2015-06-08T12:35:01+09:00</updated>
        <id>http://yoshitsugufujii.github.io/blog/2015/06/08/devise-skip-password-check</id>
        <content type="html"><![CDATA[<pre><code class="ruby">#開発環境  
rails 4.2.1  
devise 3.4.1  
</code></pre>

<p>deviseを使っていて、ユーザモデルに仮登録状態を作りたいと思います。<br/>
仮登録の段階ではパスワードはまだ要求されず。<br/>
最後の最後でパスワードを設定して本会員登録完了といったフローです。</p>

<p>deviseでは対象モデルに<code>devise :validatable</code>に設定している場合はメールアドレスやパスワードの検証が走ります。<br/>
今回はパスワード以外のチェックはやってほしいため<code>:validatable</code>の宣言を外すだけではダメです。</p>

<!-- more -->


<p>deviseの以下のソースを見てみます</p>

<pre><code class="ruby lib/devise/models/validatable.rb">def self.included(base)
  base.extend ClassMethods
  assert_validations_api!(base)

  base.class_eval do
    validates_presence_of   :email, if: :email_required?
    validates_uniqueness_of :email, allow_blank: true, if: :email_changed?
    validates_format_of     :email, with: email_regexp, allow_blank: true, if: :email_changed?

    validates_presence_of     :password, if: :password_required?
    validates_confirmation_of :password, if: :password_required?
    validates_length_of       :password, within: password_length, allow_blank: true
  end
end
</code></pre>

<p>パスワードの検証をするかどうかはpassword_required?で判定しています。
判定メソッドはこんな感じです。</p>

<pre><code class="ruby">def password_required?
  !persisted? || !password.nil? || !password_confirmation.nil?
end
</code></pre>

<p>これを対象のモデルでオーバーライドします。</p>

<pre><code class="ruby">class User &lt; ActiveRecord::Base

  devise :database_authenticatable, :registerable,
         :recoverable, :rememberable, :trackable, :validatable

  def password_required?
    if member?
      !persisted? || !password.nil? || !password_confirmation.nil?
    else
      false
    end
  end
end
</code></pre>

<p>これでmember?がtrueを返さない(本登録前のユーザ)はパスワードの検証処理をスキップできるようになります。</p>
]]></content>
    </entry>
    
    <entry>
        <title type="html"><![CDATA[deep_rejectが欲しくてrefinementsで実装しようとした話]]></title>
        <link href="http://yoshitsugufujii.github.io/blog/2015/05/26/deep-reject/"/>
        <updated>2015-05-26T19:03:54+09:00</updated>
        <id>http://yoshitsugufujii.github.io/blog/2015/05/26/deep-reject</id>
        <content type="html"><![CDATA[<p>再帰的に条件判定を行うrejectが欲しくなりました。<br/>
こういう動きです。</p>

<pre><code class="ruby">[1,2].deep_reject{|val| val == 1 }  # =&gt; [2]

[1,2, [1,2,3]].deep_reject{|val| val == 1 } # =&gt; [2, [2, 3]]

[1, 2, {a: "a", b: "b" }].deep_reject{|key, val| key == :a } # =&gt; [1, 2, {:b=&gt;"b"}]

[1, 2, {a: "a", b: "b", c: {a: "c", c: "d"} }].deep_reject{|key, val| key == :a } 
# =&gt; [1, 2, {:b=&gt;"b", :c=&gt;{:c=&gt;"d"}}]
</code></pre>

<p>かなり便利そうです。</p>

<!-- more -->


<p>refinmetsで実装してみます。</p>

<pre><code class="ruby">  module HashEx
    refine Hash do
      def deep_reject(&amp;block)
        self.each_with_object({}) do |(k, v), result|
          unless block.call(k, v)
            if v.is_a?(Hash)
              result[k] = v.deep_reject(&amp;block)
            else
              result[k] = v
            end
          end
        end
      end
    end
  end

  module ArrayEx
    refine Array do
      def deep_reject(&amp;block)
        self.each_with_object([]) do |v, result|
          unless block.call(v)
            if v.is_a?(Array)
              result &lt;&lt; v.deep_reject(&amp;block)
            elsif v.is_a?(Hash)
              result &lt;&lt; v.deep_reject(&amp;block) # 呼べない！
            else
              result &lt;&lt; v
            end
          end
        end
      end
    end
  end
</code></pre>

<p>ですがこれを
<code>ruby
using ArrayEx
using HashEx
</code></p>

<p>と読み込んで使おうとしたところ残念ながら配列の中にハッシュが紛れ込んでいるようなケースだとArrayExのdeep_rejectからHashExのdeep_rejectが参照できず思った通りの結果になりませんでした。<br/>
refinementsはかなり厳密なスコープで動くようです。</p>

<p>まぁあったら有意義なメソッドだしいいかということで結局オープンクラスで実装しました。</p>

<pre><code class="ruby">class Array
  def deep_reject(&amp;block)
    self.each_with_object([]) do |v, result|
      unless block.call(v)
        if v.is_a?(Array)
          result &lt;&lt; v.deep_reject(&amp;block)
        elsif v.is_a?(Hash)
          result &lt;&lt; v.deep_reject(&amp;block)
        else
          result &lt;&lt; v
        end
      end
    end
  end
end

class Hash
  def deep_reject(&amp;block)
    self.each_with_object({}) do |(k, v), result|
      unless block.call(k, v)
        if v.is_a?(Hash)
          result[k] = v.deep_reject(&amp;block)
        elsif v.is_a?(Array)
          result[k] = v.deep_reject(&amp;block)
        else
          result[k] = v
        end
      end
    end
  end
end
</code></pre>
]]></content>
    </entry>
    
    <entry>
        <title type="html"><![CDATA[モデルのattributeに変更がなくてもnested_attribute_forを使っているモデルでcallbackを発生させる]]></title>
        <link href="http://yoshitsugufujii.github.io/blog/2015/05/25/force-occur-callbacks/"/>
        <updated>2015-05-25T16:15:38+09:00</updated>
        <id>http://yoshitsugufujii.github.io/blog/2015/05/25/force-occur-callbacks</id>
        <content type="html"><![CDATA[<p>任意の条件でnested_attribute_forの対象の保存処理を走らせる方法です</p>

<p>ファイルのアップロード用のモデルを作っていて<code>ActionDispatch::Http::UploadedFile</code>を一旦attr_accessorのアクセサで受けたあとcallbackでファイル名やファイルサイズをmodelクラスの該当のカラムに設定するという処理を書いておりました。</p>

<p>ファイルは可変にアップロードしたかったのでこのモデルの親モデルから参照するようにして、nested_attribute_forで親モデル更新時に一緒に更新するようにします。</p>

<pre><code class="ruby">class Oya &lt; ActiveRecord::Base
  has_many :files, dependent: :destroy

  accepts_nested_attributes_for :files, allow_destroy: true
end
</code></pre>

<pre><code class="ruby">class File &lt; ActiveRecord::Base
  attr_accessor :file
end
</code></pre>

<!-- more -->


<p>いらない情報ですが、一応モデルクラスFileモデルの参照先のテーブルfilesテーブルはこんな感じです。
<code>ruby
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `created_at` datetime DEFAULT NULL,
  `updated_at` datetime DEFAULT NULL,
  `oya_id` int(11) NOT NULL,
  `data_file_name` varchar(255) DEFAULT NULL,
  `data_content_type` varchar(255) DEFAULT NULL,
  `data_file_size` int(11) DEFAULT NULL,
</code></p>

<p>新規登録の時は良かったんですが、親モデル保存時にnested_attribute_forの対象のモデルクラスのsave(auto_save)やcallbackを走らせるかどうかは実際にデータベースに登録されているカラムの値に変化があったかで決定されているようです(たぶん)</p>

<p>そのため変更時にはformからはfileというアクセサに設定する値のみ飛んでくるような作りだとauto_saveが動かずFileクラスの更新処理が走りませんでした。</p>

<p>そのためchanged_for_autosave?をオーバーライドすることで独自に変更判定を行いcallback並びにauto saveが動くようにします。</p>

<pre><code class="ruby">class File &lt; ActiveRecord::Base
  attr_accessor :file

  def changed_for_autosave?
    if file.present?
      return true
    end
    super
  end
end
</code></pre>

<p>知ってると簡単ですが、知らないとはまりますね。</p>
]]></content>
    </entry>
    
    <entry>
        <title type="html"><![CDATA[nested_formで下じゃなくて上に要素を追加したい場合]]></title>
        <link href="http://yoshitsugufujii.github.io/blog/2015/05/20/nested-form-add-field-to-top/"/>
        <updated>2015-05-20T18:03:26+09:00</updated>
        <id>http://yoshitsugufujii.github.io/blog/2015/05/20/nested-form-add-field-to-top</id>
        <content type="html"><![CDATA[<p>neste_formは可変なサイズの子要素を動的に追加できるGemです。</p>

<p><a href="https://github.com/ryanb/nested_for://github.com/ryanb/nested_form">nested form</a></p>

<p>いつも大変お世話になっておりますが、今回の案件で追加する先を指定したエレメントの下ではなく上に追加しなければいけなくなり対応しました。</p>

<!-- more -->


<p>バージョンは<br/>
<code>ruby Gemfile.lock
nested_form (0.3.2)  
</code>
での作業となります。</p>

<p>ますnested_formで使われるjsを眺めるとそんなに長くない処理であることがわかります。<br/>
その中で追加ボタンを押したときに要素を追加する部分はこの辺りになるようです。</p>

<pre><code class="js jquery_nested_form:55行目あたり">    insertFields: function(content, assoc, link) {
      var target = $(link).data('target');
      if (target) {
        return $(content).appendTo($(target));
      } else {
        return $(content).insertBefore(link);
      }
    },
</code></pre>

<p>ここを上書きします。 <br/>
application.jsで<code>//= require jquery_nested_form</code>の後に以下の処理を書いて上書きしちゃいましよう。</p>

<pre><code class="js">window.NestedFormEvents.prototype.insertFields = function(content, assoc, link) {
  var target = $(link).data('target');
  if ($(link).data('destination') == "prepend"){
    return $(target).prepend($(content));
  }else{
    if (target) {
      return $(content).appendTo($(target));
    } else {
      return $(content).insertBefore(link);
    }
  }
}
</code></pre>

<p>linkのdata-destination=prependで対象の要素の上にprependで追加されるイメージです。</p>

<p>&#8220;`erb</p>

<table id="tasks">
  <%= f.fields_for :tasks, :wrapper => false do |task_form| %>
    <tr class="fields">
      <td><%= task_form.text_field :name %></td>
      <td><%= task_form.link_to_remove "Remove this task" %></td>
    </tr>
  <% end %>
</table>


<p><p>&lt;%= f.link_to_add &ldquo;Add a task&rdquo;, :tasks, :data => { :target => &ldquo;#tasks&rdquo;, :prepend => true } %></p>
&#8220;`</p>

<p>簡単でした。</p>
]]></content>
    </entry>
    
    <entry>
        <title type="html"><![CDATA[Rails Engineを使った開発]]></title>
        <link href="http://yoshitsugufujii.github.io/blog/2015/05/19/develop-with-rails-engine/"/>
        <updated>2015-05-19T13:09:58+09:00</updated>
        <id>http://yoshitsugufujii.github.io/blog/2015/05/19/develop-with-rails-engine</id>
        <content type="html"><![CDATA[<p>一つ前に携わったプロジェクトではサブシステムがたくさんあり、それぞれがrailsで構築されていて共通処理やmodelはrails engineにあつめられ各システムで参照しておりました。</p>

<p>今までgemのコードリーディングをする時にしか意識していなかったrails engineですが(deviseとかとか)、結構便利だということを今更ながら実感し、最近は共有処理をengineに書き出してそれを参照するようにしています。</p>

<p>クックパッドさんでも共通部分をengineに集めているようです。<br/>
<a href="http://techlife.cookpad.com/entry/2015/04/06/155940">新規サービスの管理画面を短期間で見栄え良く実装する</a></p>

<p>ドリコムさんでは複数のengineを組み合わせてシステムを作っているようです。<br/>
<a href="http://blog.onk.ninja/2014/12/02/mountable_engine.html">Mountable Engine だらけの Rails アプリ開発</a></p>

<!-- more -->


<p>でも完全に共通に作ろうとすると色々考えなきゃいけないから工数がかかっちゃうんじゃないかと懸念があるかもしれません。<br/>
でも最初はそこまで共通化する必要もないのではないのかと思います。</p>

<p>git使っていれば、システムの納品段階でengineのブランチを切るなりタグを打つなりして機能を固定してしまえばいいのです。<br/>
そうすれば、今後engineに修正が加わってもGemfileで該当のブランチまたはタグを見るようにすれば問題なく納品段階のengineのコードでシステムは動き続けます。<br/>
その後時間をおいてゆっくりとプロジェクトに依存したコードを共通化していけばいいのです。</p>

<p>これを応用してめったにやらない処理であんまり入れなたくないような機能や、<br/>
モンキーパッチなども参照元のプロジェクト単位でengineをカスタマイズして導入することもできます。</p>

<p>そして共通化した処理を書くことはいつもより有益なことをしてる気持ちで仕事ができるので楽しいです。<br/>
engine固有の仕組みや書き方もあって最初は中々辛い部分もありますが、
engineを使ったことのない方は決まり切った処理をコピぺで過去のプロジェクトから持ってくるのではなく、
その処理をengineに書き出してそれをプロジェクトから参照してみてはいかがでしょうか？</p>
]]></content>
    </entry>
    
</feed>
